# Task 1:
# Сортування бульбашкою можна модифікувати для "бульбашкового" сортування в обох напрямках.
# Перший прохід переміщує список "вгору", а другий - "вниз".
# Таке чергування триває доти, доки не знадобиться більше проходів.
# Застосуйте цю варіацію і опишіть, за яких обставин вона може бути доречною.

def bubbleSort_plus(iterable):
    # Задаємо діапазон сортування (початок, кінець і крок) для використання в функції range для внутрішнього циклу
    start = 0
    stop = len(iterable) - 1
    step = 1
    for element in range(len(iterable) - 1, -1, -1):
        for i in range(start, stop, step):
            # Якщо перший елемент більше другого - міняємо їх містами
            if iterable[i] > iterable[i + 1]:
                iterable[i], iterable[i + 1] = iterable[i + 1], iterable[i]
        # Після кожного циклу сортування потрібно корегувати диапазон сортування і направлення циклу сортування:
        # Після кожного проходу міняємо містами початок і кінець діапазону для наступного проходу
        start, stop = stop, start
        # Якщо був прямий прохід (крок позитивний):
        if step > 0:
            # Зменшуємо диапазон сортування на кінці диапазону (який тепер буде start для наступного зворотнього проходу):
            start -= 1
            # А також зменшуємо індекс початку диапазону (який тепер буде stop для наступного зворотнього проходу),
            # бо при зворотньому проході цикл доходить до stop, але не включаючи його
            stop -= 1
            # Після самого першого прямого проходу потрібно stop змінити на -1
            # (щоб наступний зворотній прохід включив в обробку нульовий елемент списку):
            if start == len(iterable) - 2 and stop == 0:
                stop = -1
        # Якщо був зворотній прохід (крок негативний):
        elif step < 0:
            # Знову ж таки після першого зворотнього проходу потрібно індекс початку диапазону повернути на 0
            if start == -1:
                start = 0
            # Зменшуємо диапазон сортування з голови
            start += 1
        # А також змінюємо шаг на протилежний
        step *= -1
    return iterable

# Використання
if __name__ == '__main__':
    import random

    l = [random.randint(-10, 10) for i in range(10)]
    print(f'Невідсортований список: {l}')

    b = bubbleSort_plus(l)
    print(f'Відсортований список:   {b}')

# За яких обставин цей варіант може бути доречним? Важко сказати...можливо у випадку невеликих списків...
# Виглядає як більш оптимізоване сортування бульбашкою, але складність O(n²) все одно зберігається.